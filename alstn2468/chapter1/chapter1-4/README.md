
# 1.4 함수형 자바스크립트를 위한 기초

## 1.4.1 일급 함수

자바스크립트에서 함수는 **일급 객체**이자 **일급 함수**다.

여기에서 **일급**은 값으로 다룰 수 있다는 의미로 아래와 같은 조건을 만족해야 한다.

- 변수에 담을 수 있다.
- 함수나 메서드의 인자로 넘길 수 있다.
- 함수나 메서드에서 리턴할 수 있다.

자바스크립트에서 모든 값은 일급이며 모든 객체는 일급 객체이며 **함수는 객체이자 일급 객체**다.


- 아무 때나(런타임에서도) 선언이 가능하다.
- 익명으로 선언할 수 있다.
- 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.

일급함수는 위와 같은 추가적인 조건을 추가적으로 만족하며 아래의 예시들은 일급 함수의 특징을 표현한다.

- 코드 1-39(1) 값으로 다룰 수 있는 함수

```javascript
function f1() {}
var a = typeof f1 == 'function' ? f1 : function() {};
```

위 코드에서 `f1`은 함수를 값으로 다룰 수 있음을 보여준다. `typeof` 연산자를 사용해 `function`인지 확인하고 변수 `a`에 `f1`을 담고 있다.

- 코드 1-39(2) 함수를 반환하는 함수

```javascript
function f2() {
  return function() {}
}
```

`f2` 함수는 함수를 반환한다.

- 코드 1-39(3) 익명 함수 선언과 즉시 실행 가능한 함수

```javascript
(function (a, b) {
  return a + b;
})(10, 5); // 15
```

`a`와 `b`를 더하는 익명 함수를 선언하고 각각 10, 5를 전달하여 함수 선언 후 즉시 실행하고 있다.

- 코드 1-39(4) 익명 함수를 인자로 넘겨 실행하는 함수

```javascript
function callAndAdd(a, b) {
  return a() + b();
}
callAndAdd(function () { return 10; }, function () { return 5; }); // 15
```

`callAndAdd` 함수를 실행하면서 익명 함수를 선언해 바로 인자로 넘겼으며 `callAndAdd` 함수는 인자로 받은 함수를 실행해 결과를 반환한다.

위와 같이 함수는 언제든지 선언할 수 있고 인자로 사용할 수 있다. 또한 인자로 받은 함수를 실행할 수 있으며, 함수를 반환할 수 도 있다.

메서드를 가진 객체와 달리 함수는 자신이 곧 기능이기 때문에 보다 쉽게 참조할 수 있고 전달할 수 있고, 쉽게 실행 가능하다.

## 1.4.2 클로저

함수는 변수 참조 범위를 결정하는 중요한 기준이 된다. 함수가 중첩되어 있다면 스코프 역시 중첩되어 생겨난다.

> 클로저는 자신이 생성될 때의 환경을 기억하는 함수다.

클로저의 정의는 보통 위와 같이 설명되며 실용적으로 표현하자면 아래와 같이 표현할 수 있다.

> 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.

자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다.

자바스크립트의 모든 함수는 상위 스코프를 가지며 모든 함수는 자신이 정의되는 순간의 실행 컨텍스트 안에 있다.

따라서 자바스크릅트의 모든 함수는 어느 곳에서 생성하든 어떤 방법으로 생성하든 자신이 생성될 때의 환경을 기억할 수 있다.

관점에 따라 모든 함수는 클로저라 해석이 되거나 정의되는 경우도 존재한다.

함수가 진짜 클로저가 되기 위한 가장 중요한 조건은 아래와 같다.

- 코드 1-40 클로저가 되기 위한 가장 중요한 조건

```javascript
function parent() {
  var a = 5;
  function myfn() {
    console.log(a);
  }
}
function parent2() {
  var a = 5;
  function parent1() {
    function myfn() {
      console.log(a);
    }
  }
}
```

`parent`와 `parent2` 내부의 `myfn` 함수에서는 `a`라는 변수를 선언하지 않았지만 사용하고 있다.

`parent`의 변수 `a`는 `myfn`을 생성하는 스코프에서 정의되었고 `parent2`의 변수 `a`는 `myfn`을 생성하는 스코프의 상위 스코프에 정의되었다.

클로저의 정의를 조금 더 정확하게 정의해보면 아래와 같이 표현할 수 있을 것 이다.

> 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.

아래의 예제를 통해 클로저에 대해서 더 자세히 확인할 수 있다.

- 코드 1-41

```javascript
var a = 10;
var b = 20;
function f1() {
  return a + b;
}
f1(); // 30
```

위의 `f1` 함수는 클로저가 아니다. `f1` 함수는 클로저처럼 외부 변수를 참조해 결과를 반환하게 된다.

하지만 글로벌 스코프에서 선언된 모든 변수는 그 변수를 사용하는 함수가 있는지 없는지와 관계없이 유지된다.

`a`와 `b` 변수가 `f1` 함수에 의해 사라지지 못하는 상황이 아니므로 `f1` 함수는 클로저가 아니다.

웹 브라우저의 경우 함수 내부가 아닐 경우 모두 글로벌 스코프이지만 Node.js와 같은 환경에서는 사용하는 자바스크립트 파일 하나의 스코프는 글로벌 스코프가 아니다.

그러므로 위의 코드가 브라우저가 아닌 Node.js 환경에서 사용할 특정 자바스크립트 파일에 작성되어 있을경우 `f1` 함수는 클로저가 될 수 있다.

- 코드 1-42

```javascript
function f2() {
  var a = 10;
  var b = 20;
  function f3(c, d) {
    return c + d;
  }
  return f3;
}
var f4 = f2();
f4(5, 7); // 12
```

위의 코드 역시 클로저가 아니다. `f3` 함수는 `f2` 함수 안에서 생성되었고 `f3` 함수 바로 위에는 `a`, `b`라는 지역 변수 또한 존재한다.

하지만 `f3` 함수 안에서 사용되는 두 변수는 모두 `f3`안에서 정의되었으며 자신이 생성될 때의 스코프가 알고 있는 변수 `a`, `b`는 사용하지 않았으므로 기억되지 않는다.

- 코드 1-43

```javascript
function f4() {
  var a = 10;
  var b = 20;
  function f5() {
    return a + b;
  }
  return f5;
}
f4(); // 30
```

위의 예시는 클로저가 '있었다'라는 표현이 정확하며 결과적으로는 클로저가 없다.

`f4` 함수가 실행되고 `a`, `b`가 할당된 후 `f5` 함수가 정의도니다. 그리고 `f5` 함수에서는 `a`, `b`가 사용되었으므로 `f5` 함수는 클로저가 된다.

하지만 `f4` 함수의 마지막 라인을 보면 `f5` 함수를 실행하여 값을 반환한다.

결국 `f5` 함수를 참조하고 있는 곳이 어디에도 없으므로 `f5` 함수는 사라지고 `a`와 `b` 또한 사라질 수 있기에 클로저는 `f4` 함수가 실행되는 사이에 생겼다 사라진다.

- 코드 1-44

```javascript
function f6() {
  var a = 10;
  function f7(b) {
    return a + b;
  }
  return f7;
}
var f8 = f6();
f8(20); // 30
f8(10); // 20
```

위 코드의 `f7`은 클로저다. 위의 코드에서 `a`는 사라지지 않는다.

`f7` 함수가 `a`를 사용하기 때문에 `a`를 기억해야 하고 `f7` 함수가 `f8` 함수에 담겼기 때문에 클로저가 되었다.

> 위의 예제에서도 `f6` 함수의 결과인 `f7`을 `f8`에 담지 않았다면 `f7`은 클로저가 되지 않는다.

`f6` 함수의 실행이 끝났어도 `f7`이 `a`를 기억하는 클로저가 되었기 때문에 `a`는 사라지지 않으며 `f8`을 실행할 때 마다 새로운 변수인 `b`와 함께 사용되어 결과를 생성한다.

- 코드 1-45

```javascript
function f9() {
  var a = 10;
  var f10 = function (c) {
    return a + b + c;
  };
  var b = 20;
  return f10;
}
var f11 = f9();
f11(30); // 60
```

변수 `b`는 함수 `f10`보다 늦게 선언되었지만 `f11(30)`의 실행 결과는 60이다.

위의 예제는 클로저가 기억하고 있는 **자신이 생성될 때**의 범위를 보여주는 예시다.

`f10`이 생성될 시점에는 `b`가 20으로 초기화되지 않았다.

클로저는 자신이 생성되는 스코프의 모든 라인, 어느 곳에서 선언된 변수든지 참조하고 기억할 수 있으며 그것들은 **변수이기 때문에 클로저가 생성된 이후 언제라도 변경될 수 있다**.

다시 한번 클로저를 조금 더 풀어서 정의하면 아래와 같을 것 이다.

> 클로저는 자신이 생성되는 스코프의 실행 컨텍스트에서 만들어졌거나 알 수 있었던 변수 주 언젠가 자신이 실행될 때 사용할 변수들만 기억하는 함수이다. 클로저가 기억하는 변수의 값은 언제든지 남이나 자신에 의해 변경될 수 있다.

## 1.4.3 클로저의 실용 사례

<sub id="2021-03-05"><sup>-- 2021-03-05 --</sup></sub>

[[이전으로]](../chapter1-3/README.md) / [[뒤로가기]](../README.md)